---
title: Futhark 0.25.35 released
author: Troels Henriksen
description: A long time since I wrote one of these.
---

[Futhark 0.25.35 has just been
released](https://github.com/diku-dk/futhark/releases/tag/v0.25.35) (or perhaps
[escaped](https://www.cs.cornell.edu/courses/cs100/1999su/handouts/klingons.htm)).
I used to make a post like this for most releases, but it has actually been over
two years and 30 releases since the [previous
announcement](2023-08-30-futhark-0.25.3-released.html). Is this because Futhark
has stopped changing? In a way it is: we also have not had a change to the
middle version number (25) in two and a half years, which implies that the
language has been stable for that long. This means that programs written two and
a half years ago should still work, and in practice the changes made in 0.25.1
did not make many (if any) programs invalid - they merely [extended what you can
do](2023-07-06-futhark-0.25.1-released.html). Skimming through the changelog, it
seems that 0.22.1 was the most recent version to make a truly user-visible
change ([by removing some prelude functions that nobody
used](2022-08-15-end-of-a-language-feature.html)). In 0.21.1, we made `def` a
reserved word, which certainly broke some reasonable code. In 0.20.1 we fiddled
with some edge cases of unary operators (and made some related changes to the
prelude), which I think is perhaps the last gasp of Futhark's once instability.
It really has been a fairly stable language for quite a while now.

That does not mean nothing changes, of course. Since Futhark in its current form
is a pretty good (if still
[imperfect](2018-12-08-why-futhark-sometimes-goes-wrong.html)) language for data
parallel programming, we do a lot of investigation into parallel algorithms
where Futhark is merely a tool. William Henrich Due, a PhD student here at
[DIKU](https://diku.dk), has recently done work on data parallel algorithms for
hash maps and union-find structures ([draft paper on the
former](https://trendsfp.github.io/papers/tfp26-paper-07.pdf)), a lot of which
ends up in the [containers](https://github.com/diku-dk/containers) package for
Futhark.

Futhark itself also improves, of course. Version 0.25.35 has seen substantial
improvements in its tooling, mainly due to code contributions from
[VegOwOtenks](https://github.com/Hyalunar). In particular, `futhark profile` now
produces far more useful information, such as heat maps of the program source
code, that shows where the run-time is spent. This has already proven useful
during human trials in our [course on data-parallel
programming](https://github.com/diku-dk/dpp-e2025-pub), where some students used
it to analyse the code they wrote as part of their final projects. The work is
built on top of the [improvements to tracking source
locations](2025-07-29-tracking-source-locations.html) made last year, although
[there are still cases where it does not work so
well](https://github.com/diku-dk/futhark/issues/2361). VegOwOtenks has also
added additional features to Futhark's language server (exposing [the
formatter](2024-12-01-futhark-fmt.html)), and judging by the open pull requests,
will make several more. The language server was [written by a
student](2022-04-15-futhark-0.21.9-released.html#the-futhark-language-server) in
the first place, and is perhaps the most prominent component of Futhark that is
primarily written by non-core hackers (although I certainly use it every day
through [Eglot](https://github.com/joaotavora/eglot)).

Another nice improvement is by Amirreza Hashemi, a student at
[DTU](http://dtu.dk/), who improved the implementation of `scan` for the
`multicore` backend through an approach described in [this
paper](https://dl.acm.org/doi/10.1145/3649169.3649248), which is largely written
by the contributors to [Accelerate](https://www.acceleratehs.org/). This was
quite thorough work, that explored some of the edge cases about what should be
done when the operator or input preprocessing is complicated. I think some work
remains to be done here, but scans are in most cases quite a bit faster now,
which is always good.
